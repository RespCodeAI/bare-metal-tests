# bare-metal-tests

Source code and compiled binaries from [RespCode](https://respcode.com) Compete Mode — AI-generated bare-metal firmware tested on real hardware.

## LPC55S69-EVK — February 2026 Flagship Battle

**4 frontier AI models. Same prompt. Same board. Only 1 blinks the LED.**

Every file in this repo was generated by an AI model via RespCode, compiled with `arm-none-eabi-gcc`, validated against SVD peripheral databases, and flashed to a physical NXP LPC55S69-EVK board. Nothing was hand-edited.

**Full writeup:** [How RespCode Compiles Real Bare-Metal Firmware with AI](https://respcode.com/blog/how-respcode-compiles-baremetal-firmware)

---

## Results

| Model | Binary | SVD Fixes | Compiled | Hardware Result |
|:------|-------:|:---------:|:--------:|:----------------|
| Claude Opus 4.6 | 588 B | 0 | ✅ | ❌ Dead — correct-looking `#define` addresses, still doesn't blink |
| GPT-5.2 | 680 B | 0 | ✅ | ❌ Dead — struct offsets place every register access at wrong address |
| **Gemini 3 Pro** | **280 B** | **2** | **✅** | **✅ Blinks** |
| DeepSeek Coder | 516 B | 1 | ✅ | ❌ Dead — wrong GPIO port, hallucinated clock registers |

All four compiled. All four passed SVD base address validation. Only **Gemini 3 Pro** produced firmware that blinks the LED on real silicon.

---

## Target

| | |
|:--|:--|
| **Board** | NXP LPC55S69-EVK |
| **MCU** | LPC55S69JBD100 (ARM Cortex-M33, 150 MHz) |
| **LED** | PORT1 PIN4 — Green RGB LED, active low |
| **Flash** | 630 KB @ 0x00000000 |
| **SRAM** | 256 KB @ 0x20000000 (SRAM0–3) |

## Prompt

All four models received this exact prompt:

```
Write bare-metal LED blink firmware for the LPC55S69-EVK board.
Target: LPC55S69JBD100 (Cortex-M33)

Board details:
- LED: PORT1 PIN4 (active low)
- Flash: 630KB at 0x00000000 (NOT 640KB — 10KB reserved)
- SRAM: 256KB at 0x20000000 (SRAM0-3 only, NOT 320KB)
  Warning: SRAM4 (64KB) is in a separate power domain. Use only 256KB.

Provide: main.c, lpc55s69.h, startup.c, linker.ld
Use direct register access. No SDK.
Target: LPC55S69JBD100
```

---

## Repo Structure

```
├── claude-opus-4-6/
│   ├── source/            # AI-generated, unmodified
│   │   ├── main.c
│   │   ├── startup.c
│   │   ├── lpc55s69.h
│   │   └── linker.ld
│   └── binary/
│       └── firmware.bin   # 588 B — ❌ dead on hardware
│
├── gpt-5-2/
│   ├── source/
│   │   ├── main.c
│   │   ├── startup.c
│   │   ├── lpc55s69.h
│   │   └── linker.ld
│   └── binary/
│       └── firmware.bin   # 680 B — ❌ dead on hardware
│
├── gemini-3-pro/          # ✅ WINNER
│   ├── source/
│   │   ├── main.c
│   │   ├── startup.c
│   │   ├── lpc55s69.h     # SVD auto-fixed: SYSCON + IOCON base addresses
│   │   └── linker.ld
│   └── binary/
│       └── firmware.bin   # 280 B — ✅ blinks on real hardware
│
├── deepseek-coder/
│   ├── source/
│   │   ├── main.c
│   │   ├── startup.c
│   │   ├── lpc55s69.h     # SVD auto-fixed: GPIO base address
│   │   └── linker.ld
│   └── binary/
│       └── firmware.bin   # 516 B — ❌ dead on hardware
│
└── README.md
```

> **Note:** The source files are post-SVD-correction — these are the files as they were actually compiled. See [SVD Corrections](#svd-auto-corrections) for what was changed.

---

## Why Each Model Failed (or Succeeded)

### ✅ Gemini 3 Pro — Blinks

Minimal `#define` register macros with explicit offsets. No C structs. After SVD auto-correction of two base addresses, every register offset is correct:

- `SYSCON_AHBCLKCTRL0` → `0x40000200` ✅
- `GPIO_DIR1` → `0x4008E004` ✅
- `GPIO_NOT1` → `0x4008E304` ✅
- `IOCON_PIO1_4` → `0x400010A0` ✅

Enables IOCON clock (bit 13) and GPIO1 clock (bit 15), sets digital mode on PIO1\_4, and toggles via the NOT register.

### ❌ Claude Opus 4.6 — Dead

The most thorough code: clock init with atomic SET registers, peripheral reset release, 60-IRQ named vector table, DIGIMODE. Every `#define` address appears correct against UM11126. Yet doesn't blink. Suspected cause: IOCON pin mapping offset — uses `0x090` (sequential index 36) vs Gemini's working `0x0A0` (index 40). The LPC55S69JBD100 package-specific IOCON mapping may not be strictly sequential.

### ❌ GPT-5.2 — Dead

Most sophisticated code — proper `typedef struct` for SYSCON/GPIO, inline IOCON helper, SecureFault handler, 64-IRQ vector table. Passed 3/3 SVD checks with zero fixes. Fatal flaw: the structs assume **contiguous** register layouts, but LPC55S69 peripherals have **sparse** maps with large gaps:

| Access | GPT-5.2 Writes To | Correct Address |
|:-------|:-------------------|:----------------|
| `SYSCON->AHBCLKCTRL0` | `0x40000024` | `0x40000200` |
| `GPIO->DIR[1]` | `0x40094004` | `0x4008E004` |
| `GPIO->NOT[1]` | `0x40094304` | `0x4008E304` |

Every register access misses by thousands of bytes.

### ❌ DeepSeek Coder — Dead

Clock init uses register names from the **LPC800/LPC1100** family (`FROOSCCTRL`, `FRODIRECTCLKUEN`) — they don't exist on the LPC55S69. Targets PORT0 instead of PORT1. IOCON offset `0x104` is out of range for PIO1\_4. GPIO base was auto-corrected from `0xA0000000`, but the logic errors go far deeper than base addresses.

---

## SVD Auto-Corrections

RespCode's SVD validator compares `#define` peripheral base addresses against the official CMSIS-SVD pack for the LPC55S69 and auto-corrects mismatches before compilation:

| Model | Peripheral | Original | Corrected |
|:------|:-----------|:---------|:----------|
| Gemini 3 Pro | SYSCON | `0x50000000` | `0x40000000` |
| Gemini 3 Pro | IOCON | `0x50002000` | `0x40001000` |
| DeepSeek Coder | GPIO | `0xA0000000` | `0x4008C000` |
| Claude Opus 4.6 | — | No corrections needed | — |
| GPT-5.2 | — | No corrections needed | — |

---

## Build & Flash

### Compile from source

```bash
arm-none-eabi-gcc -mcpu=cortex-m33 -mthumb -nostdlib \
    -T source/linker.ld -o firmware.elf source/main.c source/startup.c
arm-none-eabi-objcopy -O binary firmware.elf firmware.bin
```

### Flash to board

```bash
# pyOCD
pyocd flash --target lpc55s69 binary/firmware.bin

# J-Link
JLinkExe -device LPC55S69 -if SWD -speed 4000 -autoconnect 1
J-Link> loadbin binary/firmware.bin, 0x00000000
J-Link> r
J-Link> g
```

---

## Key Takeaways

1. **Compilation ≠ correctness** — All 4 compile cleanly. Only 1 works on hardware.
2. **SVD catches base addresses, not struct offsets** — GPT-5.2 passed 3/3 SVD checks but every register access is wrong due to struct padding.
3. **Simpler code wins** — Direct `#define` macros are more reliable than typedef structs for unfamiliar MCUs.
4. **Hardware is the only real test** — Opus 4.6's code looks correct on paper and still doesn't blink. Static analysis has limits.

---

## Links

- **Blog post:** [How RespCode Compiles Real Bare-Metal Firmware with AI](https://respcode.com/blog/how-respcode-compiles-baremetal-firmware)
- **RespCode:** [respcode.com](https://respcode.com) — Multi-model AI code generation with bare-metal compilation
- **LPC55S69 User Manual:** [UM11126](https://www.nxp.com/docs/en/user-guide/UM11126.pdf)
- **LPC55S69-EVK:** [NXP Product Page](https://www.nxp.com/design/development-boards/lpcxpresso-boards/lpcxpresso55s69-development-board:LPC55S69-EVK)

## License

The AI-generated source code in this repository is provided as-is for educational and research purposes. The code was generated by third-party AI models and compiled by RespCode. No warranty is provided.
